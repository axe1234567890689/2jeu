# // import des bibliothèque

import copy
import math
import pygame
import json
from classs import Boutons
from classs import slider as SL
#pyinstaller --onefile --add-data="save/save.json:save" --add-data="image/aile.png:image" --add-data="image/angle bouton.png:image" --add-data="image/blackHole.png:image" --add-data="image/bore.png:image" --add-data="image/box.png:image" main.py
# image/aile.png;image/angle bouton.png
# // variables
# créer la fenêtre
# prépare la transformation de text en image
pygame.init()
f = pygame.font.SysFont("Arial", 40)
# permet de gereer le temp
clock = pygame.time.Clock()
# le temp entre deux refresh de screen
file_save = json.loads(open("save/save.json", "r").read())
deltatime = 0
bouton_level_size = 116
vitessex = 0
marge = 10
time = 0
lvl_select = 0
color_select = 0
nb_carer = 0
carer_select = -1
cs = -1
precision = 10
nb_click = 0
click_gauche = False
pos_click1 = (-1, -1)
menu = "main"
binding = False
show = True
spawnPoint = False
movepoint = False
bh = True
fin = False
graviter_variateur = 1
name_bind = ""
# / couleur
# couleur du fond de l'écran
couleur_fond = (200, 200, 200)
colors = [(200, 0, 0), (0, 200, 0), (0, 0, 200), (200, 200, 0), (0, 200, 200), (200, 0, 200)]
# / list
# texts à afficher chaque frames
texts = []
# boutons
boutons = []
sliders = []
# position de la souris
mouse_pos = ()

parametre = file_save["parametre"]
parametre_no_save = file_save["parametre"]
nb_level = parametre["nb level"]
screen_size = parametre["screen size"]
propy = screen_size[1] / 1080
propx = screen_size[0] / 1920
joueur = [[-1, -1], 10 * propy, 0, 240, 60 * propy, False, False, False, False]
all_terrain = file_save["level"]
for num_lvl in all_terrain:
    spawn = False
    for color in all_terrain[num_lvl]:
        if color == "spawn":
            spawn = True
            all_terrain[num_lvl][color] = [all_terrain[num_lvl][color][0] * screen_size[0], all_terrain[num_lvl][color][1] * screen_size[1]]
        else:
            for carer in all_terrain[num_lvl][color]:
                rect = all_terrain[num_lvl][color][carer]
                rect["pos"] = [rect["rect"][0] * screen_size[0], rect["rect"][1] * screen_size[1], rect["rect"][2] * screen_size[0], rect["rect"][3] * screen_size[1]]
                rect["visuel"] = [rect["pos"][0], rect["pos"][1], rect["pos"][2] - rect["pos"][0], rect["pos"][3] - rect["pos"][1]]
                if rect["spe"] and rect["aile"]:
                    rect["visuel"] = [rect["pos"][0], rect["pos"][1], 110, 110]
                    rect["pos"] = [rect["rect"][0] * screen_size[0], rect["rect"][1] * screen_size[1], rect["rect"][0] * screen_size[0] + 110, rect["rect"][1] * screen_size[1] + 110]
                if rect["spe"]:
                    rect["tp"] = [rect["tp"][0] * screen_size[0], rect["tp"][1] * screen_size[1]]
                    if rect["move"] != 0:
                        rect["point"] = []
                        for p in rect["poss"]:
                            rect["point"].append([p[0] * screen_size[0], p[1] * screen_size[1]])
                        rect["cible"] = rect["point"][1]
                        y = rect["cible"][1] - rect["pos"][1]
                        x = rect["cible"][0] - rect["pos"][0]
                        rect["exangle"] = math.atan2(y, x)
    if not spawn:
        all_terrain[num_lvl]["spawn"] = [0.9 * screen_size[0], 0.9 * screen_size[1]]
# charge les images
aile_image = pygame.transform.scale(pygame.image.load("image/aile.png"), (110, 110))
Upleftcorner_image = pygame.image.load("image/angle bouton.png")
Upleftcorner_image = pygame.transform.scale(Upleftcorner_image, (32, 32))
Uprightcorner_image = pygame.transform.rotate(Upleftcorner_image, -90)
Downrightcorner_image = pygame.transform.rotate(Uprightcorner_image, -90)
Downleftcorner_image = pygame.transform.rotate(Downrightcorner_image, -90)
borehaut_image = pygame.image.load("image/bore.png")
borehaut_image = pygame.transform.scale(borehaut_image, (1, 16))
boredroite_image = pygame.transform.rotate(borehaut_image, -90)
borebas_image = pygame.transform.rotate(boredroite_image, -90)
boregauche_image = pygame.transform.rotate(borebas_image, -90)
boxcornerUpLeft_image = pygame.image.load("image/box.png")
boxcornerUpLeft_image = pygame.transform.scale(boxcornerUpLeft_image, (16, 16))
boxcornerUpRight_image = pygame.transform.rotate(boxcornerUpLeft_image, -90)
boxcornerDownRight_image = pygame.transform.rotate(boxcornerUpRight_image, -90)
boxcornerDownLeft_image = pygame.transform.rotate(boxcornerDownRight_image, -90)
blackHole_image = [pygame.transform.scale(pygame.image.load("image/blackHole.png"), (70, 70))]
angle = 0
while angle <= 355:
    blackHole_image.append(pygame.transform.rotate(blackHole_image[0], -angle))
    angle += 5
for image in blackHole_image:
    image = pygame.transform.scale(image, (70, 70))
screen = pygame.display.set_mode(screen_size)
screen_center = (screen_size[0] / 2, screen_size[1] / 2)


# // fonctions

# permet de charger les elements d'un menu précis
def menu_select():
    global menu, show, sliders, carer_select, joueur, graviter_variateur, lvl_select, pos_click1
    boutons.clear()
    texts.clear()
    sliders.clear()
    pos_click1 = (-1, -1)
    if menu == "main":
        boutons.append(Boutons.Bouton(f, 4, "EDITEUR DE NIVEAUX", (500, screen_size[1] - 600), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 1, "SELECT LEVEL", (500, screen_size[1] - 450), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "SETTINGS", (500, screen_size[1] - 300), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "QUIT", (500, screen_size[1] - 150), screen_size[0]))
    elif menu == "level selector":
        rest = screen_size[0] / (bouton_level_size + marge)
        rest = rest - int(rest)
        rest /= 2
        rest *= (bouton_level_size + marge)
        nb_boutonx = int(screen_size[0] / (bouton_level_size + marge))
        nb_boutony = int((screen_size[1] - 60) / (bouton_level_size + marge))
        index = 0
        for y in range(nb_boutony):
            for x in range(nb_boutonx):
                if index < nb_level:
                    if index == 0:
                        text = "TUTO"
                    else:
                        text = str(index)
                    index += 1
                    boutons.append(Boutons.Bouton(f, index, text, (x * (bouton_level_size + marge) + rest, y * (bouton_level_size + marge) + rest + 60), pos2=(x * (bouton_level_size + marge) + bouton_level_size + rest, y * (bouton_level_size + marge) + bouton_level_size + rest + 60)))
        boutons.append(Boutons.Bouton(f, index + 1, "x", (10, 10), pos2=(50, 50), animable=False))
        boutons[-1].text_pos = (20, 5)
    elif menu == "level" or menu == "test":
        joueur = [copy.copy(all_terrain[str(lvl_select)]["spawn"]), 10 * propy, 0, 240, 60 * propy, False, False, False, False]
        graviter_variateur = 1
        for color in all_terrain[str(lvl_select)]:
            if not color == "spawn" and not color == "objectif":
                for carer in all_terrain[str(lvl_select)][color]:
                    rect = all_terrain[str(lvl_select)][color][str(carer)]
                    if rect["spe"]:
                        if rect["aile"]:
                            rect["keep"] = False
                            rect["visuel"] = [rect["visuel"][0], rect["visuel"][1], 110, 110]
                            rect["pos"] = [rect["visuel"][0], rect["visuel"][1], rect["visuel"][0] + 110, rect["visuel"][1] + 110]
                        if rect["move"] > 0:
                            rect["visuel"] = copy.copy([rect["point"][0][0], rect["point"][0][1], rect["visuel"][2], rect["visuel"][3]])
                            rect["pos"] = copy.copy([rect["point"][0][0], rect["point"][0][1], rect["visuel"][0] + rect["visuel"][2], rect["visuel"][1] + rect["visuel"][3]])
    elif menu == "settings" or menu == "settings pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "SAVE", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "KEYBIND", (screen_center[0], screen_center[1] + 25), screen_size[0]))
    elif menu == "keybind" or menu == "keybindl":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        x = screen_center[0]
        y = screen_center[1] - 270
        i = 1
        for action in parametre["touches"]:
            image1 = f.render(action, True, (0, 0, 0))
            image2 = f.render(pygame.key.name(parametre_no_save["touches"][action]), True, (0, 0, 0))
            texts.append([action, (0, 0, 0), (x - image1.get_width() + image1.get_width() / 4, y), 30])
            boutons.append(Boutons.Bouton(f,i, pygame.key.name(parametre_no_save["touches"][action]), (x, y - 20), pos2=(x + 300, y + 60)))
            boutons[-1].text_pos = (x + 150 - (image2.get_width() / 2), y)
            i += 1
            y += 100
    elif menu == "pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "MENU", (screen_center[0], screen_center[1] + 25), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "QUIT", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "SETTINGS", (screen_center[0], screen_center[1] - 100), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 4, "LEVEL SELECTOR", (screen_center[0], screen_center[1] - 225), screen_size[0]))
    elif menu == "editeur":
        for color in all_terrain[str(lvl_select)]:
            if not color == "spawn" and not color == "objectif":
                for carer in all_terrain[str(lvl_select)][color]:
                    rect = all_terrain[str(lvl_select)][color][carer]
                    if rect["spe"]:
                        if rect["aile"]:
                            rect["keep"] = False
                        if rect["move"] > 0:
                            rect["visuel"][0] = rect["point"][0][0]
                            rect["visuel"][1] = rect["point"][0][1]
                            rect["pos"][0] = rect["point"][0][0]
                            rect["pos"][1] = rect["point"][0][1]
        show = True
        carer_select = -1
        joueur = [[-1, -1], 10 * propy, 0, 240, 60 * propy, False, False, False, False]
        boutons.append(Boutons.Bouton(f, 0, "QUITTER", (20, screen_size[1] - 123)))
        QUITTER = f.render("QUITTER", False, (0, 0, 0))
        boutons.append(Boutons.Bouton(f, 1, "TESTER", (QUITTER.get_width() + 150, screen_size[1] - 123)))


# affiche un text sur la fenêtre
def afficher_text(text, couleur, pos, taille):
    text_font = pygame.font.SysFont("arial", taille)
    text = text_font.render(text, True, couleur)
    screen.blit(text, pos)


# affiche chaque Frame
def affichage(deltatime):
    screen.fill(couleur_fond)

    if menu == "level" or menu == "pause" or menu == "settings pause" or menu == "test" or menu == "editeur":
        draw_level(deltatime)

    if pos_click1 != (-1, -1):
        mp = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
        minx = min(mp[0], pos_click1[0])
        miny = min(mp[1], pos_click1[1])
        maxx = max(mp[0], pos_click1[0])
        maxy = max(mp[1], pos_click1[1])
        pygame.draw.rect(screen, colors[color_select], [minx, miny, maxx - minx, maxy - miny])

    if menu == "editeur":
        for x in range(int(screen_size[0] / precision)):
            for y in range(int(screen_size[1] / precision)):
                pygame.draw.rect(screen, (255, 255, 255), (x * precision, y * precision, 1, 1))
        if spawnPoint:
            pygame.draw.circle(screen, (0, 0, 0), [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision], 10)
        else:
            pygame.draw.circle(screen, (0, 0, 0), all_terrain[str(lvl_select)]["spawn"], 10)
        if show:
            if carer_select != -1:
                pygame.draw.rect(screen, (100, 100, 100), (screen_size[0] - 400, 0, 400, screen_size[1]))
                rect = all_terrain[str(lvl_select)][str(color_select)][str(carer_select)]
                if rect["spe"]:
                    if rect["tp"] != [0, 0]:
                        pygame.draw.circle(screen, colors[color_select], [rect["tp"][0] * screen_size[0], rect["tp"][1] * screen_size[1]], 10)
                    elif rect["move"]:
                        if movepoint:
                            pygame.draw.circle(screen, (0, 0, 0), [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision], 10)

    if show or not menu == "editeur":
        for bouton in boutons:
            if bouton.animate:
                if bouton.is_select:
                    prop = bouton.temp_passer / bouton.temp_animation
                else:
                    prop = -bouton.temp_passer / bouton.temp_animation + 1
                screen.blit(Upleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                 transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
                screen.blit(Downrightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                                    transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
                screen.blit(Uprightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                                  transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
                screen.blit(Downleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                   transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
                prop = -prop + 1
                screen.blit(boxcornerUpLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                    transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
                screen.blit(boxcornerUpRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                     transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
                screen.blit(boxcornerDownRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                       transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
                screen.blit(boxcornerDownLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                      transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))

                c = [transition(0, 20, prop) - 1]

                bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
                screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                                   transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
                bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
                screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                                   transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
                bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
                screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                   transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))
                bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
                screen.blit(bore, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                   transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))

                pygame.draw.rect(screen, (255, 158, 109), (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                                                           transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16,
                                                           (bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0],
                                                           (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
            else:
                if bouton.is_select and bouton.animable:
                    screen.blit(Upleftcorner_image, bouton.pos1)
                    screen.blit(Downrightcorner_image, (bouton.pos2[0] - 32, bouton.pos2[1] - 32))
                    screen.blit(Uprightcorner_image, (bouton.pos2[0] - 32, bouton.pos1[1]))
                    screen.blit(Downleftcorner_image, (bouton.pos1[0], bouton.pos2[1] - 32))

                    screen.blit(boxcornerUpLeft_image, (bouton.pos1[0] + 10, bouton.pos1[1] + 10))
                    screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 26, bouton.pos1[1] + 10))
                    screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 26, bouton.pos2[1] - 26))
                    screen.blit(boxcornerDownLeft_image, (bouton.pos1[0] + 10, bouton.pos2[1] - 26))

                    bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                    screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos1[1] + 10))
                    bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                    screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos2[1] - 26))
                    bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                    screen.blit(bore, (bouton.pos1[0] + 10, bouton.pos1[1] + 26))
                    bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                    screen.blit(bore, (bouton.pos2[0] - 26, bouton.pos1[1] + 26))

                    pygame.draw.rect(screen, (255, 158, 109), (
                    bouton.pos1[0] + 26, bouton.pos1[1] + 26, (bouton.pos2[0] - bouton.pos1[0]) - 52,
                    (bouton.pos2[1] - bouton.pos1[1]) - 52))
                else:
                    screen.blit(boxcornerUpLeft_image, bouton.pos1)
                    screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 16, bouton.pos1[1]))
                    screen.blit(boxcornerDownLeft_image, (bouton.pos1[0], bouton.pos2[1] - 16))
                    screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 16, bouton.pos2[1] - 16))

                    bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                    screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos1[1]))
                    bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                    screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos2[1] - 16))
                    bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                    screen.blit(bore, (bouton.pos1[0], bouton.pos1[1] + 16))
                    bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                    screen.blit(bore, (bouton.pos2[0] - 16, bouton.pos1[1] + 16))

                    pygame.draw.rect(screen, (255, 158, 109), (
                    bouton.pos1[0] + 16, bouton.pos1[1] + 16, (bouton.pos2[0] - bouton.pos1[0]) - 32,
                    (bouton.pos2[1] - bouton.pos1[1]) - 32))

            screen.blit(bouton.text, bouton.text_pos)
    for Slider in sliders:
        Slider.draw(screen)

    for text in texts:
        afficher_text(text[0], text[1], text[2], text[3])

    pygame.display.flip()


# dessine les c omposer du niveau
def draw_level(deltatime):
    for index in all_terrain["all"][str(color_select)]:
        pygame.draw.rect(screen, colors[color_select], all_terrain["all"][str(color_select)][index]["visuel"])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        rect = all_terrain[str(lvl_select)][str(color_select)][index]
        if not rect["spe"]:
            if not rect["trigger"] and rect["final"]:
                colo = colors[color_select]
                pygame.draw.rect(screen, colo, all_terrain[str(lvl_select)][str(color_select)][index]["visuel"], 5)
            else:
                colo = colors[color_select]
                pygame.draw.rect(screen, colo, all_terrain[str(lvl_select)][str(color_select)][index]["visuel"])
        elif not rect["blackhole"] > 0 and not rect["aile"]:
            if rect["graviter"] != 1:
                colo = (255, 255, 0)
            elif rect["tp"] != [0, 0]:
                colo = (0, 255, 255)
            elif rect["bump"] != 0:
                colo = (255, 0, 255)
            else:
                colo = colors[color_select]
            pygame.draw.rect(screen, colo, all_terrain[str(lvl_select)][str(color_select)][index]["visuel"])
        elif rect["blackhole"] > 0:
            image = blackHole_image[int((-time + 1) * 25)]
            screen.blit(image, (rect["visuel"][0] - image.get_width() / 2, rect["visuel"][1] - image.get_height() / 2))
        elif not rect["keep"]:
            screen.blit(aile_image, (rect["visuel"][0], rect["visuel"][1]))
        if rect["spe"]:
            if rect["move"] != 0:
                y = rect["cible"][1] - rect["pos"][1]
                x = rect["cible"][0] - rect["pos"][0]
                angle = math.atan2(y, x)
                if max(angle - rect["exangle"], rect["exangle"] - angle) > math.pi / 2:
                    rect["stape"] += 1
                    if rect["stape"] > rect["move"]:
                        rect["stape"] = 0
                    rect["cible"] = rect["point"][rect["stape"]]
                    y = rect["cible"][1] - rect["pos"][1]
                    x = rect["cible"][0] - rect["pos"][0]
                    angle = math.atan2(y, x)
                rect["exangle"] = angle
                mx = math.cos(angle) * rect["speed"] * deltatime
                my = math.sin(angle) * rect["speed"] * deltatime
                if rect["pos"][0] < joueur[0][0] < rect["pos"][2]:
                    if rect["pos"][1] - joueur[1] - 2 < joueur[0][1] < rect["pos"][1]:
                        joueur[0][0] += mx
                        joueur[0][1] += my
                rect["pos"][0] += mx
                rect["pos"][2] += mx
                rect["pos"][1] += my
                rect["pos"][3] += my
                rect["visuel"][0] += mx
                rect["visuel"][1] += my

    if joueur[8]:
        screen.blit(aile_image, (joueur[0][0] - 55, joueur[0][1] - 70))
    if show or not menu == "editeur":
        pygame.draw.circle(screen, colors[color_select], joueur[0], joueur[1])


# permet de connaitre une position pendant une transition
def transition(nb1, nb2, prop):
    return nb1 * prop + nb2 * (-prop + 1)


# regarde chaque input
def save_setting():
    for category in parametre:
        parametre_no_save[category] = parametre[category]


def bouton_action(select):
    global menu, lvl_select, binding, name_bind, color_select, nb_level, texts, show, cs, boutons, movepoint
    if menu == "main":
        if select == 1:
            menu = "level selector"
            menu_select()
        elif select == 2:
            menu = "settings"
            menu_select()
        elif select == 4:
            menu = "editeur"
            menu_select()
            nb_level += 1
            lvl_select = nb_level - 1
            color_select = 0
            all_terrain[str(lvl_select)] = {"0": {}, "1": {}, "2": {}, "3": {}, "4": {}, "5": {}, "spawn": [100, 100]}
            color_select = 0
        elif select == 3:
            quite()
    elif menu == "level selector":
        if select == nb_level + 1:
            menu = "main"
            menu_select()
        else:
            menu = "level"
            lvl_select = select - 1
            color_select = 0
            menu_select()
    elif menu == "level":
        menu = "main"
        menu_select()
    elif menu == "pause":
        if select == 0:
            menu = "level"
            menu_select()
        elif select == 1:
            menu = "main"
            menu_select()
        elif select == 2:
            quite()
        elif select == 3:
            menu = "settings pause"
            menu_select()
        elif select == 4:
            menu = "level selector"
            menu_select()
    elif menu == "settings pause":
        if select == 0 or select == 1:
            menu = "pause"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybindl"
            menu_select()
    elif menu == "settings":
        if select == 0 or select == 1:
            menu = "main"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybind"
            menu_select()
    elif menu == "keybind":
        if select == 0:
            menu = "settings"
            menu_select()
        else:
            binding = True
            i = 1
            for action in parametre["touches"]:
                if i == select:
                    name_bind = action
                i += 1
    elif menu == "keybindl":
        if select == 0:
            menu = "settings pause"
            menu_select()
    elif menu == "editeur":
        if select == 0:
            menu = "main"
            menu_select()
        elif select == 1:
            menu = "test"
            menu_select()
        else:
            rect = all_terrain[str(lvl_select)][str(color_select)][carer_select]
            if select == 2:
                rect["trigger"] = not rect["trigger"]
                text = "OUI"
                if rect["trigger"]:
                    text = "NON"
                f = pygame.font.SysFont("arial", 30)
                boutons[2].text = f.render(text, False, (0, 0, 0))
                if not rect["trigger"] and not rect["spe"]:
                    t = f.render("objectif", False, (0, 0, 0))
                    texts.append(["objectif", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 170), 30])
                    rect["final"] = False
                    text = "NON"
                    boutons.append(Boutons.Bouton(f, 4, text, (screen_size[0] - 150, 160), pos2=(screen_size[0] - 50, 220)))
                    boutons[-1].text_pos = (screen_size[0] - 130, 175)
                elif not rect["spe"]:
                    texts = texts[0:2]
                    boutons = boutons[0:4]
            elif select == 3:
                rect["spe"] = not rect["spe"]
                f = pygame.font.SysFont("arial", 30)
                text = "NON"
                if rect["spe"]:
                    text = "OUI"
                boutons[3].text = f.render(text, False, (0, 0, 0))
                if rect["spe"]:
                    sliders.clear()
                    texts = texts[0:2]
                    boutons = boutons[0:4]
                    text = "OUI"
                    rect["graviter"] = 1
                    rect["tp"] = [0, 0]
                    rect["bump"] = 0
                    rect["move"] = 0
                    rect["blackhole"] = 0
                    rect["aile"] = False
                    t = f.render("changement", False, (0, 0, 0))
                    texts.append(["changement", (0, 0, 0), (screen_size[0] - t.get_width() - 50, 130), 30])
                    t = f.render("de graviter", False, (0, 0, 0))
                    texts.append(["de graviter", (0, 0, 0), (screen_size[0] - t.get_width() - 50, 150), 30])
                    sliders.append(SL.Slider((screen_size[0] - 350, 200), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), -10, 10, 0, 1))
                    sliders[-1].set_value(rect["graviter"] + 10)
                    t = f.render("TP", False, (0, 0, 0))
                    texts.append(["TP", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 240), 30])
                    boutons.append(Boutons.Bouton(f, 4, "mettre un point de", (screen_size[0] - 340, 270), pos2=(screen_size[0] - 50, 370)))
                    t = f.render("teleportation", False, (0, 0, 0))
                    texts.append(["teleportation", (0, 0, 0), (screen_size[0] - t.get_width() - 100, 320), 30])
                    boutons[-1].text_pos = (screen_size[0] - 320, 290)
                    t = f.render("rebond", False, (0, 0, 0))
                    texts.append(["rebond", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 370), 30])
                    sliders.append(SL.Slider((screen_size[0] - 350, 400), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 0, 500, 0, 2))
                    sliders[-1].set_value(rect["bump"])
                    t = f.render("Trous noir", False, (0, 0, 0))
                    texts.append(["Trous noir", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 430), 30])
                    sliders.append(SL.Slider((screen_size[0] - 350, 460), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 0, 1000000, 0, 3))
                    sliders[-1].set_value(rect["blackhole"])
                    t = f.render("deuxième saut", False, (0, 0, 0))
                    texts.append(["deuxième saut", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 510), 30])
                    text = "NON"
                    boutons.append(Boutons.Bouton(f, 5, text, (screen_size[0] - 150, 500), pos2=(screen_size[0] - 50, 560)))
                    boutons[-1].text_pos = (screen_size[0] - 130, 515)
                    t = f.render("mouvement", False, (0, 0, 0))
                    texts.append(["mouvement", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 580), 30])
                    text = "NON"
                    boutons.append(Boutons.Bouton(f, 6, text, (screen_size[0] - 150, 570), pos2=(screen_size[0] - 50, 630)))
                    boutons[-1].text_pos = (screen_size[0] - 130, 585)
                else:
                    sliders.clear()
                    texts = texts[0:2]
                    boutons = boutons[0:4]
                    if not rect["trigger"]:
                        t = f.render("objectif", False, (0, 0, 0))
                        texts.append(["objectif", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 170), 30])
                        rect["final"] = False
                        text = "NON"
                        boutons.append(Boutons.Bouton(f, 4, text, (screen_size[0] - 150, 160), pos2=(screen_size[0] - 50, 220)))
                        boutons[-1].text_pos = (screen_size[0] - 130, 175)
            elif select == 6:
                rect["move"] = -rect["move"] + 1
                text = "NON"
                f = pygame.font.SysFont("arial", 30)
                if rect["move"]:
                    text = "OUI"
                    rect["speed"] = 100
                    rect["stape"] = 1
                    rect["poss"] = [rect["rect"][0:2], rect["rect"][0:2]]
                    rect["point"] = [rect["visuel"][0:2], rect["visuel"][0:2]]
                    rect["cible"] = copy.copy(rect["point"][1])
                    rect["exangle"] = 0
                    t = f.render("vitesse", False, (0, 0, 0))
                    texts.append(["vitesse", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 600), 30])
                    sliders.append(SL.Slider((screen_size[0] - 350, 630), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 5, 500, 0, 4))
                    sliders[-1].set_value(rect["speed"])
                    t = f.render("point de passage", False, (0, 0, 0))
                    texts.append(["point de passage", (0, 0, 0), (screen_size[0] - t.get_width() - 100, 650), 30])
                    boutons.append(Boutons.Bouton(f, 7, "mettre un point de", (screen_size[0] - 340, 690), pos2=(screen_size[0] - 50, 770)))
                    boutons[-1].text_pos = (screen_size[0] - 300, 700)
                    t = f.render("passage", False, (0, 0, 0))
                    texts.append(["passage", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 720), 30])
                else:
                    texts = texts[0:10]
                    boutons = boutons[0:7]
                    sliders.remove(sliders[-1])
                boutons[6].text = f.render(text, False, (0, 0, 0))
            elif select == 5:
                rect["aile"] = not rect["aile"]
                text = "NON"
                if rect["aile"]:
                    text = "OUI"
                    rect["keep"] = False
                f = pygame.font.SysFont("arial", 30)
                boutons[5].text = f.render(text, False, (0, 0, 0))
            elif select == 4:
                if not rect["spe"] and not rect["trigger"]:
                    rect["final"] = not rect["final"]
                    text = "NON"
                    if rect["final"]:
                        text = "OUI"
                    f = pygame.font.SysFont("arial", 30)
                    boutons[-1].text = f.render(text, False, (0, 0, 0))
                else:
                    cs = carer_select
                    menu_select()
                show = False
            elif select == 7:
                movepoint = True
                cs = carer_select
                menu_select()


def inpute():
    global mouse_pos, deltatime, menu, binding, color_select, joueur, show, click_gauche, nb_click, pos_click1, nb_carer, carer_select, cs, spawnPoint, boutons, movepoint
    mouse_pos = pygame.mouse.get_pos()

    select = -1
    if not menu == "editeur" or show:
        for bouton in boutons:
            if not bouton.only_draw:
                selectint = bouton.is_trigger(mouse_pos)
                if selectint is not None:
                    select = selectint
                bouton.stape(deltatime)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            quite()
        elif event.type == pygame.KEYDOWN:
            if binding:
                parametre_no_save["touches"][name_bind] = event.key
                menu_select()
                binding = False
            elif menu == "level" or menu == "test":
                if event.key == parametre["touches"]["PAUSE"]:
                    if menu == "level":
                        menu = "pause"
                        menu_select()
                    else:
                        menu = "editeur"
                        menu_select()
                elif event.key == parametre["touches"]["AVANCER DANS LES COULEURS"]:
                    color_select += 1
                    if color_select >= 6:
                        color_select -= 6
                    if color_select > lvl_select:
                        color_select -= (lvl_select + 1)
                elif event.key == parametre["touches"]["RECULER DANS LES COULEURS"]:
                    color_select -= 1
                    if color_select < 0:
                        color_select += min((lvl_select + 1), 6)
                elif event.key == parametre["touches"]["SAUTER"]:
                    if joueur[5]:
                        if graviter_variateur < 0:
                            joueur[2] += 400
                        else:
                            joueur[2] -= 400
                        joueur[5] = False
                    elif joueur[8]:
                        if graviter_variateur < 0:
                            joueur[2] += 400
                        else:
                            joueur[2] -= 400
                        joueur[8] = False
                elif event.key == pygame.K_t and menu == "test":
                    joueur[0] = [mouse_pos[0], mouse_pos[1]]
                elif event.key == pygame.K_r:
                    menu_select()
                elif event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = True
                elif event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = True
                elif event.key == pygame.K_t:
                    joueur[0] = [mouse_pos[0], mouse_pos[1]]
            elif menu == "editeur":
                if event.key == pygame.K_TAB:
                    show = not show
                elif event.key == pygame.K_p:
                    print(json.dumps(all_terrain[str(lvl_select)]))
                elif event.key == pygame.K_DELETE:
                    if carer_select != -1:
                        all_terrain[str(lvl_select)][str(color_select)].pop(str(carer_select))
                        carer_select = -1
                        menu_select()
                elif event.key == parametre["touches"]["AVANCER DANS LES COULEURS"]:
                    color_select += 1
                    if color_select >= 6:
                        color_select -= 6
                    if color_select > lvl_select:
                        color_select -= (lvl_select + 1)
                    carer_select = -1
                elif event.key == parametre["touches"]["RECULER DANS LES COULEURS"]:
                    color_select -= 1
                    if color_select < 0:
                        color_select += min((lvl_select + 1), 6)
                    carer_select = -1
        elif event.type == pygame.KEYUP:
            if menu == "level" or menu == "test":
                if event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = False
                if event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = event.pos
            if event.button == 1 and select != -1 and select is not None:
                bouton_action(select)
            elif event.button == 1:
                if cs == -1:
                    if menu == "editeur":
                        if not pos_click1 == (-1, -1):
                            mp = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                            minx = min(mp[0], pos_click1[0])
                            miny = min(mp[1], pos_click1[1])
                            maxx = max(mp[0], pos_click1[0])
                            maxy = max(mp[1], pos_click1[1])
                            all_terrain[str(lvl_select)][str(color_select)][str(nb_carer)] = {"rect": [minx / screen_size[0], miny / screen_size[1], maxx / screen_size[0], maxy / screen_size[1]], "pos": [minx, miny, maxx, maxy], "visuel": [minx, miny, maxx - minx, maxy - miny], "trigger": True, "spe": False}
                            nb_carer += 1
                            pos_click1 = (-1, -1)
                        else:
                            if distcarrer(all_terrain[str(lvl_select)]["spawn"], mouse_pos) < joueur[1] ** 2:
                                if spawnPoint:
                                    all_terrain[str(lvl_select)]["spawn"] = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                                spawnPoint = not spawnPoint
                            elif spawnPoint:
                                spawnPoint = False
                                all_terrain[str(lvl_select)]["spawn"] = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                            else:
                                click_gauche = True
                                nb_click = 0
                                for Slider in sliders:
                                    if Slider.click(mouse_pos):
                                        nb_click = Slider.nb
                                if nb_click == 0 and carer_select == -1 or nb_click == 0 and mouse_pos[0] < screen_size[0] - 400:
                                    carer_select = -1
                                    for carer in all_terrain[str(lvl_select)][str(color_select)]:
                                        rect = all_terrain[str(lvl_select)][str(color_select)][carer]["pos"]
                                        if rect[0] <= mouse_pos[0] <= rect[2] and rect[1] <= mouse_pos[1] <= rect[3]:
                                            sliders.clear()
                                            texts.clear()
                                            boutons = [boutons[0], boutons[1]]
                                            rect = all_terrain[str(lvl_select)][str(color_select)][carer]
                                            carer_select = carer
                                            f = pygame.font.SysFont("arial", 30)
                                            t = f.render("traversable", False, (0, 0, 0))
                                            texts.append(["traversable", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 10), 30])
                                            text = "NON"
                                            if not rect["trigger"]:
                                                text = "OUI"
                                            boutons.append(Boutons.Bouton(f, 2, text, (screen_size[0] - 150, 0), pos2=(screen_size[0] - 50, 60)))
                                            boutons[-1].text_pos = (screen_size[0] - 130, 15)
                                            t = f.render("speciale", False, (0, 0, 0))
                                            texts.append(["speciale", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 90), 30])
                                            text = "OUI"
                                            if not rect["spe"]:
                                                text = "NON"
                                            boutons.append(Boutons.Bouton(f, 3, text, (screen_size[0] - 150, 80), pos2=(screen_size[0] - 50, 140)))
                                            boutons[-1].text_pos = (screen_size[0] - 130, 95)
                                            if rect["spe"]:
                                                t = f.render("changement", False, (0, 0, 0))
                                                texts.append(["changement", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 130), 30])
                                                t = f.render("de graviter", False, (0, 0, 0))
                                                texts.append(["de graviter", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 150), 30])
                                                sliders.append(SL.Slider((screen_size[0] - 350, 200), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), -10, 10, 0, 1))
                                                sliders[0].set_value(rect["graviter"] + 10)
                                                t = f.render("TP", False, (0, 0, 0))
                                                texts.append(["TP", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 240), 30])
                                                boutons.append(Boutons.Bouton(f, 4, "mettre un point de", (screen_size[0] - 340, 270), pos2=(screen_size[0] - 50, 370)))
                                                t = f.render("teleportation", False, (0, 0, 0))
                                                texts.append(["teleportation", (0, 0, 0), (screen_size[0] - t.get_width() - 100, 320), 30])
                                                boutons[-1].text_pos = (screen_size[0] - 320, 290)
                                                t = f.render("rebond", False, (0, 0, 0))
                                                texts.append(["rebond", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 370), 30])
                                                sliders.append(SL.Slider((screen_size[0] - 350, 400), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 0, 500, 0, 2))
                                                sliders[1].set_value(rect["bump"])
                                                t = f.render("Trous noir", False, (0, 0, 0))
                                                texts.append(["Trous noir", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 430), 30])
                                                sliders.append(SL.Slider((screen_size[0] - 350, 460), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 0, 1000000, 0, 3))
                                                sliders[-1].set_value(rect["blackhole"])
                                                t = f.render("deuxième saut", False, (0, 0, 0))
                                                texts.append(["deuxième saut", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 510), 30])
                                                text = "NON"
                                                boutons.append(Boutons.Bouton(f, 5, text, (screen_size[0] - 150, 500), pos2=(screen_size[0] - 50, 560)))
                                                boutons[-1].text_pos = (screen_size[0] - 130, 515)
                                                t = f.render("mouvement", False, (0, 0, 0))
                                                texts.append(["mouvement", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 580), 30])
                                                text = "NON"
                                                boutons.append(Boutons.Bouton(f, 6, text, (screen_size[0] - 150, 570), pos2=(screen_size[0] - 50, 630)))
                                                boutons[-1].text_pos = (screen_size[0] - 130, 585)
                                                if rect["move"]:
                                                    t = f.render("vitesse", False, (0, 0, 0))
                                                    texts.append(["vitesse", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 600), 30])
                                                    sliders.append(SL.Slider((screen_size[0] - 350, 630), (300, 20), (200, 200, 200), (100, 100, 100), (0, 0, 0), 5, 500, 0, 4))
                                                    sliders[-1].set_value(rect["speed"])
                                                    t = f.render("point de passage", False, (0, 0, 0))
                                                    texts.append(["point de passage", (0, 0, 0), (screen_size[0] - t.get_width() - 100, 650), 30])
                                                    boutons.append(Boutons.Bouton(f, 7, "mettre un point de", (screen_size[0] - 340, 690), pos2=(screen_size[0] - 50, 770)))
                                                    boutons[-1].text_pos = (screen_size[0] - 300, 700)
                                                    t = f.render("passage", False, (0, 0, 0))
                                                    texts.append(["passage", (0, 0, 0), (screen_size[0] - t.get_width() - 150, 720), 30])
                                            elif not rect["trigger"]:
                                                t = f.render("objectif", False, (0, 0, 0))
                                                texts.append(["objectif", (0, 0, 0), (screen_size[0] - t.get_width() - 200, 170), 30])
                                                text = "OUI"
                                                if not rect["final"]:
                                                    text = "NON"
                                                boutons.append(Boutons.Bouton(f, 4, text, (screen_size[0] - 150, 160), pos2=(screen_size[0] - 50, 220)))
                                                boutons[-1].text_pos = (screen_size[0] - 130, 175)
                                if nb_click == 0 and carer_select == -1:
                                    menu_select()
                                    if pos_click1 == (-1, -1):
                                        pos_click1 = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                elif movepoint:
                    all_terrain[str(lvl_select)][str(color_select)][str(cs)]["point"][1] = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                    all_terrain[str(lvl_select)][str(color_select)][str(cs)]["poss"][1] = [all_terrain[str(lvl_select)][str(color_select)][str(cs)]["point"][1][0] / screen_size[0], all_terrain[str(lvl_select)][str(color_select)][str(cs)]["point"][1][1] / screen_size[1]]
                    movepoint = False
                    cs = -1
                else:
                    all_terrain[str(lvl_select)][str(color_select)][str(cs)]["tp"] = [int((mouse_pos[0] + precision / 2) / precision) * precision, int((mouse_pos[1] + precision / 2) / precision) * precision]
                    cs = -1
            elif menu == "editeur":
                menu_select()
        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1:
                click_gauche = False

    if click_gauche and not nb_click == 0:
        for slider in sliders:
            if slider.nb == nb_click:
                slider.calcule(mouse_pos[0])
                if slider.nb == 1:
                    all_terrain[str(lvl_select)][str(color_select)][str(carer_select)]["graviter"] = slider.value
                elif slider.nb == 2:
                    all_terrain[str(lvl_select)][str(color_select)][str(carer_select)]["bump"] = slider.value
                elif slider.nb == 3:
                    all_terrain[str(lvl_select)][str(color_select)][str(carer_select)]["blackhole"] = slider.value
                elif slider.nb == 4:
                    all_terrain[str(lvl_select)][str(color_select)][str(carer_select)]["speed"] = slider.value


# tout est dans le nom
def sauvegarde():
    file_save["parametre"]["nb level"] = nb_level
    file_save["level"] = all_terrain
    for level in all_terrain:
        for color in all_terrain[level]:
            if color == "spawn":
                all_terrain[level][color] = [all_terrain[level][color][0] / screen_size[0], all_terrain[level][color][1] / screen_size[1]]
            else:
                for block in all_terrain[level][color]:
                    rect = all_terrain[level][color][block]
                    rect["pos"] = 1
                    rect.pop("pos")
                    rect["visuel"] = 1
                    rect.pop("visuel")
                    if rect["spe"]:
                        if not rect["move"]:
                            rect["speed"] = 1
                            rect.pop("speed")
                            rect["stape"] = 1
                            rect.pop("stape")
                            rect["exangle"] = 1
                            rect.pop("exangle")
                            rect["point"] = 1
                            rect.pop("point")
                        else:
                            rect["point"] = 1
                            rect.pop("point")
                            rect["cible"] = 1
                            rect.pop("cible")
                        if not rect["tp"] == [0, 0]:
                            rect["tp"] = [rect["tp"][0] / screen_size[0], rect["tp"][1] / screen_size[1]]
                    else:
                        rect["speed"] = 1
                        rect.pop("speed")
                        rect["stape"] = 1
                        rect.pop("stape")
                        rect["point"] = 1
                        rect.pop("point")
                        rect["exangle"] = 1
                        rect.pop("exangle")
                        rect["graviter"] = 1
                        rect.pop("graviter")
                        rect["tp"] = 1
                        rect.pop("tp")
                        rect["bump"] = 1
                        rect.pop("bump")
                        rect["move"] = 1
                        rect.pop("move")
                        rect["blackhole"] = 1
                        rect.pop("blackhole")
                        rect["aile"] = 1
                        rect.pop("aile")
                        rect["keep"] = 1
                        rect.pop("keep")
                        if rect["trigger"]:
                            rect["final"] = 1
                            rect.pop("final")
    file_sauvegarde = open("save/save.json", "w+")
    file_sauvegarde.write(json.dumps(file_save, indent=2))


def quite():
    sauvegarde()
    pygame.quit()
    quit()


def collision(rect, pos, r):
    global graviter_variateur, joueur, menu, lvl_select, color_select, fin
    recte = rect['pos']
    if rect["trigger"]:
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1]:
                joueur[5] = True
                return [pos[0], pos[1] - (recte[1] - pos[1] - r) * -1]
            elif recte[3] < pos[1] < recte[3] + r:
                return [pos[0], pos[1] + (pos[1] - recte[3] - r) * -1]
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0]:
                return [pos[0] - (recte[0] - pos[0] - r) * -1, pos[1]]
            elif recte[2] < pos[0] < recte[2] + r:
                return [pos[0] + (pos[0] - recte[2] - r) * -1, pos[1]]
    elif rect["spe"]:
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1] or recte[3] < pos[1] < recte[3] + r:
                graviter_variateur = rect["graviter"]
                if not rect["tp"] == [0, 0]:
                    return [rect["tp"][0], rect["tp"][1]]
                if graviter_variateur < 0:
                    joueur[2] += rect["bump"]
                else:
                    joueur[2] -= rect["bump"]
                if rect["aile"]:
                    if not rect["keep"]:
                        joueur[8] = True
                        rect["keep"] = True
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0] or recte[2] < pos[0] < recte[2] + r:
                graviter_variateur = rect["graviter"]
                if not rect["tp"] == [0, 0]:
                    return [rect["tp"][0], rect["tp"][1]]
                if graviter_variateur < 0:
                    joueur[2] += rect["bump"]
                else:
                    joueur[2] -= rect["bump"]
                if rect["aile"]:
                    if not rect["keep"]:
                        joueur[8] = True
                        rect["keep"] = True
    elif rect["final"] and menu == "level":
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1]:
                fin = True
            elif recte[3] < pos[1] < recte[3] + r:
                fin = True
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0]:
                fin = True
            elif recte[2] < pos[0] < recte[2] + r:
                fin = True

    return pos


def distcarrer(p1, p2):
    x = p1[0] - p2[0]
    y = p1[1] - p2[1]
    return x * x + y * y


def frame_stape(deltatime):
    global joueur, color_select, menu, lvl_select, fin, vitessex, bh
    expos = joueur[0][1]
    joueur[5] = False
    joueur[0][1] += joueur[2] * deltatime + 9.81 * deltatime * deltatime * joueur[4] * graviter_variateur
    d = joueur[0][1] - expos
    expos = joueur[0][1]
    if joueur[6]:
        joueur[0][0] += joueur[3] * deltatime
    if joueur[7]:
        joueur[0][0] -= joueur[3] * deltatime
    joueur[2] = d / deltatime
    for index in all_terrain["all"][str(color_select)]:
        joueur[0] = collision(all_terrain["all"][str(color_select)][index], joueur[0], joueur[1])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        rect = all_terrain[str(lvl_select)][str(color_select)][index]
        if not rect["spe"] or rect["blackhole"] == 0:
            joueur[0] = collision(rect, joueur[0], joueur[1])
        else:
            dc = distcarrer(joueur[0], (rect["visuel"][0], rect["visuel"][1]))
            if dc < 100:
                joueur[0] = [all_terrain[str(lvl_select)]["spawn"][0], all_terrain[str(lvl_select)]["spawn"][1]]
                menu_select()
                break
            angle = math.atan2(joueur[0][1] - rect["visuel"][1], joueur[0][0] - rect["visuel"][0])
            force = min(rect["blackhole"] / dc, 50)
            vitessex -= math.cos(angle) * force
            joueur[0][0] += vitessex * deltatime
            joueur[2] -= math.sin(angle) * force
            if force > 10:
                bh = True
    if not expos == joueur[0][1]:
        if not bh:
            joueur[2] = 0
            vitessex = 0
        else:
            bh = False
    if fin:
        color_select = 0
        if lvl_select + 1 == nb_level:
            menu = "main"
        else:
            lvl_select += 1
        menu_select()
        fin = False


menu_select()
while True:
    deltatime = clock.tick() / 1000
    time += deltatime
    if time >= 3:
        time -= 3

    affichage(deltatime)
    if menu == "level" or menu == "test":
        frame_stape(deltatime)
    inpute()
