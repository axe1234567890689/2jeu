# // import des bibliothèque

# affichage
import pygame
# sauvegarde
import json
# on sait jamais
import math
# les boutons
from classs import Boutons

# // variables
# prépare la transformation de text en image
pygame.init()
f = pygame.font.SysFont("Arial", 40)
# permet de gereer le temp
clock = pygame.time.Clock()
# ouvre le fichier sauvegarde
file_save = json.loads(open("save.json", "r").read())
# le temp entre deux refresh de screen
deltatime = 0
# le nombre de level créer
nb_level = 50
# le nombre de level debloquer
nb_level_unlock = 20
# / le selecteur de level
# la taille des boutons
bouton_level_size = 116
# l'ecart entre les boutons
marge = 10
# le level selectionner
lvl_select = 0
# la couleur selectionner
color_select = 0
# le menu selectionner
menu = "main"
# si tu veux changer une touche
binding = False
# quel touche changer
name_bind = ""
# / couleur
# couleur du fond de l'écran
couleur_fond = (200, 200, 200)
# / list
# texts à afficher chaque frames
texts = []
# boutons
boutons = []
# toute les couleurs
colors = [(200, 0, 0), (0, 200, 0), (0, 0, 200), (200, 200, 0), (0, 200, 200), (200, 0, 200)]
# position de la souris
mouse_pos = ()

# les parametre a utiliser in game
parametre = file_save["parametre"]
# parametre modifier
parametre_no_save = file_save["parametre"]
# taille de l'ecrans
screen_size = parametre["screen size"]
# proportion x et y pour l'adaptation
propy = screen_size[1] / 1080
propx = screen_size[0] / 1920
# def du joueur = [pos, rayon, vitesse y, vitesse x, double jump, jump, gauche, droite]
joueur = [[100, 1000], 10 * propy, 0, 240, False, True, False, False]
# stocke chaque terrain
all_terrain = file_save["level"]
# traite le ficher
for num_lvl in all_terrain:
    for color in all_terrain[num_lvl]:
        for carer in all_terrain[num_lvl][color]:
            all_terrain[num_lvl][color][carer]["pos"] = (all_terrain[num_lvl][color][carer]["rect"][0] * screen_size[0], all_terrain[num_lvl][color][carer]["rect"][1] * screen_size[1], all_terrain[num_lvl][color][carer]["rect"][2] * screen_size[0], all_terrain[num_lvl][color][carer]["rect"][3] * screen_size[1])
            all_terrain[num_lvl][color][carer]["visuel"] = (all_terrain[num_lvl][color][carer]["pos"][0], all_terrain[num_lvl][color][carer]["pos"][1], all_terrain[num_lvl][color][carer]["pos"][2] - all_terrain[num_lvl][color][carer]["pos"][0], all_terrain[num_lvl][color][carer]["pos"][3] - all_terrain[num_lvl][color][carer]["pos"][1])
# charge et transforme les images
Upleftcorner_image = pygame.image.load("image/angle bouton.png")
Upleftcorner_image = pygame.transform.scale(Upleftcorner_image, (32, 32))
Uprightcorner_image = pygame.transform.rotate(Upleftcorner_image, -90)
Downrightcorner_image = pygame.transform.rotate(Uprightcorner_image, -90)
Downleftcorner_image = pygame.transform.rotate(Downrightcorner_image, -90)
borehaut_image = pygame.image.load("image/bore.png")
borehaut_image = pygame.transform.scale(borehaut_image, (1, 16))
boredroite_image = pygame.transform.rotate(borehaut_image, -90)
borebas_image = pygame.transform.rotate(boredroite_image, -90)
boregauche_image = pygame.transform.rotate(borebas_image, -90)
boxcornerUpLeft_image = pygame.image.load("image/box.png")
boxcornerUpLeft_image = pygame.transform.scale(boxcornerUpLeft_image, (16, 16))
boxcornerUpRight_image = pygame.transform.rotate(boxcornerUpLeft_image, -90)
boxcornerDownRight_image = pygame.transform.rotate(boxcornerUpRight_image, -90)
boxcornerDownLeft_image = pygame.transform.rotate(boxcornerDownRight_image, -90)
screen = pygame.display.set_mode(screen_size)
screen_center = (screen_size[0] / 2, screen_size[1] / 2)


# // fonctions

# permet de charger les elements d'un menu précis
def menu_select():
    global menu
    boutons.clear()
    texts.clear()
    if menu == "main":
        boutons.append(Boutons.Bouton(f, 1, "SELECT LEVEL", (500, screen_size[1] - 450), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "SETTINGS", (500, screen_size[1] - 300), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "QUIT", (500, screen_size[1] - 150), screen_size[0]))
    elif menu == "level selector":
        rest = screen_size[0] / (bouton_level_size + marge)
        rest = rest - int(rest)
        rest /= 2
        rest *= (bouton_level_size + marge)
        nb_boutonx = int(screen_size[0] / (bouton_level_size + marge))
        nb_boutony = int((screen_size[1] - 60) / (bouton_level_size + marge))
        index = 0
        for y in range(nb_boutony):
            for x in range(nb_boutonx):
                if index < nb_level:
                    if index == 0:
                        text = "TUTO"
                    else:
                        text = str(index)
                    index += 1
                    boutons.append(Boutons.Bouton(f, index, text, (x * (bouton_level_size + marge) + rest, y * (bouton_level_size + marge) + rest + 60), pos2=(x * (bouton_level_size + marge) + bouton_level_size + rest, y * (bouton_level_size + marge) + bouton_level_size + rest + 60)))
        boutons.append(Boutons.Bouton(f, index + 1, "x", (10, 10), pos2=(50, 50), animable=False))
        boutons[-1].text_pos = (20, 5)
    elif menu == "level":
        pass
    elif menu == "settings" or menu == "settings pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "SAVE", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "KEYBIND", (screen_center[0], screen_center[1] + 25), screen_size[0]))
    elif menu == "keybind" or menu == "keybindl":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        x = screen_center[0]
        y = screen_center[1] - 270
        i = 1
        for action in parametre["touches"]:
            image1 = f.render(action, True, (0, 0, 0))
            image2 = f.render(pygame.key.name(parametre_no_save["touches"][action]), True, (0, 0, 0))
            texts.append([action, (0, 0, 0), (x - image1.get_width() + image1.get_width() / 4, y), 30])
            boutons.append(Boutons.Bouton(f,i, pygame.key.name(parametre_no_save["touches"][action]), (x, y - 20), pos2=(x + 300, y + 60)))
            boutons[-1].text_pos = (x + 150 - (image2.get_width() / 2), y)
            i += 1
            y += 100
    elif menu == "pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "MENU", (screen_center[0], screen_center[1] + 25), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "QUIT", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "SETTINGS", (screen_center[0], screen_center[1] - 100), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 4, "LEVEL SELECTOR", (screen_center[0], screen_center[1] - 225), screen_size[0]))


# affiche un text sur la fenêtre
def afficher_text(text, couleur, pos, taille):
    text_font = pygame.font.SysFont("arial", taille)
    text = text_font.render(text, True, couleur)
    screen.blit(text, pos)


# affiche chaque Frame
def affichage():
    screen.fill(couleur_fond)

    if menu == "level" or menu == "pause" or menu == "settings pause":
        draw_level()

    for bouton in boutons:
        if bouton.animate:
            if bouton.is_select:
                prop = bouton.temp_passer / bouton.temp_animation
            else:
                prop = -bouton.temp_passer / bouton.temp_animation + 1
            screen.blit(Upleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                             transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(Downrightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                                transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
            screen.blit(Uprightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                              transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(Downleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                               transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
            prop = -prop + 1
            screen.blit(boxcornerUpLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(boxcornerUpRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                 transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(boxcornerDownRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                   transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
            screen.blit(boxcornerDownLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                  transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))

            c = [transition(0, 20, prop) - 1]

            bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                               transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
            bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))
            bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
            screen.blit(bore, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))

            pygame.draw.rect(screen, (255, 158, 109), (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                                                       transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16,
                                                       (bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0],
                                                       (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
        else:
            if bouton.is_select and bouton.animable:
                screen.blit(Upleftcorner_image, bouton.pos1)
                screen.blit(Downrightcorner_image, (bouton.pos2[0] - 32, bouton.pos2[1] - 32))
                screen.blit(Uprightcorner_image, (bouton.pos2[0] - 32, bouton.pos1[1]))
                screen.blit(Downleftcorner_image, (bouton.pos1[0], bouton.pos2[1] - 32))

                screen.blit(boxcornerUpLeft_image, (bouton.pos1[0] + 10, bouton.pos1[1] + 10))
                screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 26, bouton.pos1[1] + 10))
                screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 26, bouton.pos2[1] - 26))
                screen.blit(boxcornerDownLeft_image, (bouton.pos1[0] + 10, bouton.pos2[1] - 26))

                bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos1[1] + 10))
                bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos2[1] - 26))
                bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                screen.blit(bore, (bouton.pos1[0] + 10, bouton.pos1[1] + 26))
                bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                screen.blit(bore, (bouton.pos2[0] - 26, bouton.pos1[1] + 26))

                pygame.draw.rect(screen, (255, 158, 109), (
                bouton.pos1[0] + 26, bouton.pos1[1] + 26, (bouton.pos2[0] - bouton.pos1[0]) - 52,
                (bouton.pos2[1] - bouton.pos1[1]) - 52))
            else:
                screen.blit(boxcornerUpLeft_image, bouton.pos1)
                screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 16, bouton.pos1[1]))
                screen.blit(boxcornerDownLeft_image, (bouton.pos1[0], bouton.pos2[1] - 16))
                screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 16, bouton.pos2[1] - 16))

                bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos1[1]))
                bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos2[1] - 16))
                bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                screen.blit(bore, (bouton.pos1[0], bouton.pos1[1] + 16))
                bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                screen.blit(bore, (bouton.pos2[0] - 16, bouton.pos1[1] + 16))

                pygame.draw.rect(screen, (255, 158, 109), (
                bouton.pos1[0] + 16, bouton.pos1[1] + 16, (bouton.pos2[0] - bouton.pos1[0]) - 32,
                (bouton.pos2[1] - bouton.pos1[1]) - 32))

        screen.blit(bouton.text, bouton.text_pos)

    for text in texts:
        afficher_text(text[0], text[1], text[2], text[3])

    pygame.display.flip()


# dessine les c omposer du niveau
def draw_level():
    for index in all_terrain["all"][str(color_select)]:
        pygame.draw.rect(screen, colors[color_select], all_terrain["all"][str(color_select)][index]["visuel"])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        pygame.draw.rect(screen, colors[color_select], all_terrain[str(lvl_select)][str(color_select)][index]["visuel"])

    pygame.draw.circle(screen, colors[color_select], joueur[0], joueur[1])


# permet de connaitre une position pendant une transition
def transition(nb1, nb2, prop):
    return nb1 * prop + nb2 * (-prop + 1)


# regarde chaque input
def save_setting():
    for category in parametre:
        parametre_no_save[category] = parametre[category]


def bouton_action(select):
    global menu, lvl_select, binding, name_bind, color_select
    if menu == "main":
        if select == 1:
            menu = "level selector"
            menu_select()
        elif select == 2:
            menu = "settings"
            menu_select()
        elif select == 3:
            quite()
    elif menu == "level selector":
        if select == nb_level + 1:
            menu = "main"
            menu_select()
        else:
            menu = "level"
            menu_select()
            lvl_select = select - 1
            color_select = 0
    elif menu == "level":
        menu = "main"
        menu_select()
    elif menu == "pause":
        if select == 0:
            menu = "level"
            menu_select()
        elif select == 1:
            menu = "main"
            menu_select()
        elif select == 2:
            quite()
        elif select == 3:
            menu = "settings pause"
            menu_select()
        elif select == 4:
            menu = "level selector"
            menu_select()
    elif menu == "settings pause":
        if select == 0 or select == 1:
            menu = "pause"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybindl"
            menu_select()
    elif menu == "settings":
        if select == 0 or select == 1:
            menu = "main"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybind"
            menu_select()
    elif menu == "keybind":
        if select == 0:
            menu = "settings"
            menu_select()
        else:
            binding = True
            i = 1
            for action in parametre["touches"]:
                if i == select:
                    name_bind = action
                i += 1
    elif menu == "keybindl":
        if select == 0:
            menu = "settings pause"
            menu_select()


def inpute():
    global mouse_pos, deltatime, menu, binding, color_select, joueur
    mouse_pos = pygame.mouse.get_pos()

    select = -1
    for bouton in boutons:
        if not bouton.only_draw:
            selectint = bouton.is_trigger(mouse_pos)
            if selectint is not None:
                select = selectint
            bouton.stape(deltatime)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            quite()
        elif event.type == pygame.KEYDOWN:
            if binding:
                parametre_no_save["touches"][name_bind] = event.key
                menu_select()
                binding = False
            elif menu == "level":
                if event.key == parametre["touches"]["PAUSE"]:
                    menu = "pause"
                    menu_select()
                elif event.key == parametre["touches"]["AVANCER DANS LES COULEURS"]:
                    color_select += 1
                    if color_select >= 6:
                        color_select -= 6
                    if color_select > lvl_select:
                        color_select -= (lvl_select + 1)
                elif event.key == parametre["touches"]["RECULER DANS LES COULEURS"]:
                    color_select -= 1
                    if color_select < 0:
                        color_select += min((lvl_select + 1), 6)
                elif event.key == parametre["touches"]["SAUTER"]:
                    if joueur[5]:
                        joueur[2] -= 400
                elif event.key == pygame.K_t:
                    joueur[0] = [mouse_pos[0], mouse_pos[1]]
                if event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = True
                if event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = True
        elif event.type == pygame.KEYUP:
            if menu == "level":
                if event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = False
                if event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and select != -1 and select is not None:
                bouton_action(select)


# tout est dans le nom
def quite():
    pygame.quit()
    quit()


def dist(p1, p2):
    x = p1[0] - p2[0]
    y = p1[1] - p2[1]
    return x * x + y * y


def collision(rect, pos, r):
    recte = rect['pos']
    if rect["trigger"]:
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1]:
                return [pos[0], pos[1] - (recte[1] - pos[1] - r) * -1]
            elif recte[3] < pos[1] < recte[3] + r:
                return [pos[0], pos[1] + (pos[1] - recte[3] - r) * -1]
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0]:
                return [pos[0] - (recte[0] - pos[0] - r) * -1, pos[1]]
            elif recte[2] < pos[0] < recte[2] + r:
                return [pos[0] + (pos[0] - recte[2] - r) * -1, pos[1]]

    return pos


def frame_stape(deltatime):
    global joueur
    expos = joueur[0][1]
    joueur[0][1] += joueur[2] * deltatime + 9.81 * deltatime * deltatime * joueur[4]
    d = joueur[0][1] - expos
    expos = joueur[0][1]
    if joueur[6]:
        joueur[0][0] += joueur[3] * deltatime
    if joueur[7]:
        joueur[0][0] -= joueur[3] * deltatime
    for index in all_terrain["all"][str(color_select)]:
        joueur[0] = collision(all_terrain["all"][str(color_select)][index], joueur[0], joueur[1])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        joueur[0] = collision(all_terrain[str(lvl_select)][str(color_select)][index], joueur[0], joueur[1])
    if expos == joueur[0][1]:
        joueur[2] = d / deltatime
    else:
        joueur[2] = 0


menu_select()
while True:
    deltatime = clock.tick() / 1000

    affichage()
    if menu == "level":
        frame_stape(deltatime)
    inpute()
