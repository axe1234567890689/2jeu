# // import des bibliothèque
import math

import pygame
import json
from classs import Boutons

# // variables
# créer la fenêtre
# prépare la transformation de text en image
pygame.init()
f = pygame.font.SysFont("Arial", 40)
# permet de gereer le temp
clock = pygame.time.Clock()
# le temp entre deux refresh de screen
file_save = json.loads(open("save.json", "r").read())
deltatime = 0
nb_level = 50
nb_level_unlock = 20
bouton_level_size = 116
marge = 10
lvl_select = 0
color_select = 0
colors = [(200, 0, 0), (0, 200, 0), (0, 0, 200), (200, 200, 0), (0, 200, 200), (200, 0, 200)]
menu = "main"
binding = False
graviter_variateur = 1
name_bind = ""
# / couleur
# couleur du fond de l'écran
couleur_fond = (200, 200, 200)
# / list
# texts à afficher chaque frames
texts = []
# boutons
boutons = []
# position de la souris
mouse_pos = ()

parametre = file_save["parametre"]
parametre_no_save = file_save["parametre"]
screen_size = parametre["screen size"]
propy = screen_size[1] / 1080
propx = screen_size[0] / 1920
joueur = [[100, 1000], 10 * propy, 0, 240, 60 * propy, True, False, False]
all_terrain = file_save["level"]
for num_lvl in all_terrain:
    for color in all_terrain[num_lvl]:
        for carer in all_terrain[num_lvl][color]:
            rect = all_terrain[num_lvl][color][carer]
            rect["pos"] = [rect["rect"][0] * screen_size[0], rect["rect"][1] * screen_size[1], rect["rect"][2] * screen_size[0], rect["rect"][3] * screen_size[1]]
            rect["visuel"] = [rect["pos"][0], rect["pos"][1], rect["pos"][2] - rect["pos"][0], rect["pos"][3] - rect["pos"][1]]
            if rect["spe"]:
                if rect["move"] != 0:
                    rect["point"] = []
                    for p in rect["poss"]:
                        rect["point"].append([p[0] * screen_size[0], p[1] * screen_size[1]])
                    rect["cible"] = rect["point"][1]
                    y = rect["cible"][1] - rect["pos"][1]
                    x = rect["cible"][0] - rect["pos"][0]
                    rect["exangle"] = math.atan2(y, x)
# charge les images
Upleftcorner_image = pygame.image.load("image/angle bouton.png")
Upleftcorner_image = pygame.transform.scale(Upleftcorner_image, (32, 32))
Uprightcorner_image = pygame.transform.rotate(Upleftcorner_image, -90)
Downrightcorner_image = pygame.transform.rotate(Uprightcorner_image, -90)
Downleftcorner_image = pygame.transform.rotate(Downrightcorner_image, -90)
borehaut_image = pygame.image.load("image/bore.png")
borehaut_image = pygame.transform.scale(borehaut_image, (1, 16))
boredroite_image = pygame.transform.rotate(borehaut_image, -90)
borebas_image = pygame.transform.rotate(boredroite_image, -90)
boregauche_image = pygame.transform.rotate(borebas_image, -90)
boxcornerUpLeft_image = pygame.image.load("image/box.png")
boxcornerUpLeft_image = pygame.transform.scale(boxcornerUpLeft_image, (16, 16))
boxcornerUpRight_image = pygame.transform.rotate(boxcornerUpLeft_image, -90)
boxcornerDownRight_image = pygame.transform.rotate(boxcornerUpRight_image, -90)
boxcornerDownLeft_image = pygame.transform.rotate(boxcornerDownRight_image, -90)
screen = pygame.display.set_mode(screen_size)
screen_center = (screen_size[0] / 2, screen_size[1] / 2)


# // fonctions

# permet de charger les elements d'un menu précis
def menu_select():
    global menu
    boutons.clear()
    texts.clear()
    if menu == "main":
        boutons.append(Boutons.Bouton(f, 1, "SELECT LEVEL", (500, screen_size[1] - 450), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "SETTINGS", (500, screen_size[1] - 300), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "QUIT", (500, screen_size[1] - 150), screen_size[0]))
    elif menu == "level selector":
        rest = screen_size[0] / (bouton_level_size + marge)
        rest = rest - int(rest)
        rest /= 2
        rest *= (bouton_level_size + marge)
        nb_boutonx = int(screen_size[0] / (bouton_level_size + marge))
        nb_boutony = int((screen_size[1] - 60) / (bouton_level_size + marge))
        index = 0
        for y in range(nb_boutony):
            for x in range(nb_boutonx):
                if index < nb_level:
                    if index == 0:
                        text = "TUTO"
                    else:
                        text = str(index)
                    index += 1
                    boutons.append(Boutons.Bouton(f, index, text, (x * (bouton_level_size + marge) + rest, y * (bouton_level_size + marge) + rest + 60), pos2=(x * (bouton_level_size + marge) + bouton_level_size + rest, y * (bouton_level_size + marge) + bouton_level_size + rest + 60)))
        boutons.append(Boutons.Bouton(f, index + 1, "x", (10, 10), pos2=(50, 50), animable=False))
        boutons[-1].text_pos = (20, 5)
    elif menu == "level":
        pass
    elif menu == "settings" or menu == "settings pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "SAVE", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "KEYBIND", (screen_center[0], screen_center[1] + 25), screen_size[0]))
    elif menu == "keybind" or menu == "keybindl":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        x = screen_center[0]
        y = screen_center[1] - 270
        i = 1
        for action in parametre["touches"]:
            image1 = f.render(action, True, (0, 0, 0))
            image2 = f.render(pygame.key.name(parametre_no_save["touches"][action]), True, (0, 0, 0))
            texts.append([action, (0, 0, 0), (x - image1.get_width() + image1.get_width() / 4, y), 30])
            boutons.append(Boutons.Bouton(f,i, pygame.key.name(parametre_no_save["touches"][action]), (x, y - 20), pos2=(x + 300, y + 60)))
            boutons[-1].text_pos = (x + 150 - (image2.get_width() / 2), y)
            i += 1
            y += 100
    elif menu == "pause":
        boutons.append(Boutons.Bouton(f, -1, "", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] + 400, screen_center[1] + 300), only_draw=True))
        boutons.append(Boutons.Bouton(f, 0, "x", (screen_center[0] - 400, screen_center[1] - 300), pos2=(screen_center[0] - 350, screen_center[1] - 250), animable=False))
        boutons[-1].text_pos = (screen_center[0] - 385, screen_center[1] - 300)
        boutons.append(Boutons.Bouton(f, 1, "MENU", (screen_center[0], screen_center[1] + 25), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 2, "QUIT", (screen_center[0], screen_center[1] + 150), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 3, "SETTINGS", (screen_center[0], screen_center[1] - 100), screen_size[0]))
        boutons.append(Boutons.Bouton(f, 4, "LEVEL SELECTOR", (screen_center[0], screen_center[1] - 225), screen_size[0]))


# affiche un text sur la fenêtre
def afficher_text(text, couleur, pos, taille):
    text_font = pygame.font.SysFont("arial", taille)
    text = text_font.render(text, True, couleur)
    screen.blit(text, pos)


# affiche chaque Frame
def affichage():
    screen.fill(couleur_fond)

    if menu == "level" or menu == "pause" or menu == "settings pause":
        draw_level()

    for bouton in boutons:
        if bouton.animate:
            if bouton.is_select:
                prop = bouton.temp_passer / bouton.temp_animation
            else:
                prop = -bouton.temp_passer / bouton.temp_animation + 1
            screen.blit(Upleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                             transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(Downrightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                                transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
            screen.blit(Uprightcorner_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 32,
                                              transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(Downleftcorner_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                               transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 32))
            prop = -prop + 1
            screen.blit(boxcornerUpLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(boxcornerUpRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                 transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            screen.blit(boxcornerDownRight_image, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                                                   transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
            screen.blit(boxcornerDownLeft_image, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                                                  transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))

            c = [transition(0, 20, prop) - 1]

            bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop)))
            bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0], 16))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                               transition(bouton.pos2[1], bouton.pos2[1] - 10, prop) - 16))
            bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
            screen.blit(bore, (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop),
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))
            bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
            screen.blit(bore, (transition(bouton.pos2[0], bouton.pos2[0] - 10, prop) - 16,
                               transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16))

            pygame.draw.rect(screen, (255, 158, 109), (transition(bouton.pos1[0], bouton.pos1[0] + 10, prop) + 16,
                                                       transition(bouton.pos1[1], bouton.pos1[1] + 10, prop) + 16,
                                                       (bouton.pos2[0] - bouton.pos1[0]) - 32 - c[0],
                                                       (bouton.pos2[1] - bouton.pos1[1]) - 32 - c[0]))
        else:
            if bouton.is_select and bouton.animable:
                screen.blit(Upleftcorner_image, bouton.pos1)
                screen.blit(Downrightcorner_image, (bouton.pos2[0] - 32, bouton.pos2[1] - 32))
                screen.blit(Uprightcorner_image, (bouton.pos2[0] - 32, bouton.pos1[1]))
                screen.blit(Downleftcorner_image, (bouton.pos1[0], bouton.pos2[1] - 32))

                screen.blit(boxcornerUpLeft_image, (bouton.pos1[0] + 10, bouton.pos1[1] + 10))
                screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 26, bouton.pos1[1] + 10))
                screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 26, bouton.pos2[1] - 26))
                screen.blit(boxcornerDownLeft_image, (bouton.pos1[0] + 10, bouton.pos2[1] - 26))

                bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos1[1] + 10))
                bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 52, 16))
                screen.blit(bore, (bouton.pos1[0] + 26, bouton.pos2[1] - 26))
                bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                screen.blit(bore, (bouton.pos1[0] + 10, bouton.pos1[1] + 26))
                bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 52))
                screen.blit(bore, (bouton.pos2[0] - 26, bouton.pos1[1] + 26))

                pygame.draw.rect(screen, (255, 158, 109), (
                bouton.pos1[0] + 26, bouton.pos1[1] + 26, (bouton.pos2[0] - bouton.pos1[0]) - 52,
                (bouton.pos2[1] - bouton.pos1[1]) - 52))
            else:
                screen.blit(boxcornerUpLeft_image, bouton.pos1)
                screen.blit(boxcornerUpRight_image, (bouton.pos2[0] - 16, bouton.pos1[1]))
                screen.blit(boxcornerDownLeft_image, (bouton.pos1[0], bouton.pos2[1] - 16))
                screen.blit(boxcornerDownRight_image, (bouton.pos2[0] - 16, bouton.pos2[1] - 16))

                bore = pygame.transform.scale(borehaut_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos1[1]))
                bore = pygame.transform.scale(borebas_image, ((bouton.pos2[0] - bouton.pos1[0]) - 32, 16))
                screen.blit(bore, (bouton.pos1[0] + 16, bouton.pos2[1] - 16))
                bore = pygame.transform.scale(boregauche_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                screen.blit(bore, (bouton.pos1[0], bouton.pos1[1] + 16))
                bore = pygame.transform.scale(boredroite_image, (16, (bouton.pos2[1] - bouton.pos1[1]) - 32))
                screen.blit(bore, (bouton.pos2[0] - 16, bouton.pos1[1] + 16))

                pygame.draw.rect(screen, (255, 158, 109), (
                bouton.pos1[0] + 16, bouton.pos1[1] + 16, (bouton.pos2[0] - bouton.pos1[0]) - 32,
                (bouton.pos2[1] - bouton.pos1[1]) - 32))

        screen.blit(bouton.text, bouton.text_pos)

    for text in texts:
        afficher_text(text[0], text[1], text[2], text[3])

    pygame.display.flip()


# dessine les c omposer du niveau
def draw_level():
    for index in all_terrain["all"][str(color_select)]:
        pygame.draw.rect(screen, colors[color_select], all_terrain["all"][str(color_select)][index]["visuel"])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        rect = all_terrain[str(lvl_select)][str(color_select)][index]
        if not rect["spe"]:
            colo = colors[color_select]
        elif rect["graviter"] != 1:
            colo = (200, 200, 0)
        elif rect["tp"] != [0, 0]:
            colo = (0, 200, 200)
        elif rect["bump"] != 0:
            colo = (200, 0, 200)
        pygame.draw.rect(screen, colo, all_terrain[str(lvl_select)][str(color_select)][index]["visuel"])
        if rect["spe"]:
            if rect["move"] != 0:
                y = rect["cible"][1] - rect["pos"][1]
                x = rect["cible"][0] - rect["pos"][0]
                angle = math.atan2(y, x)
                if max(angle - rect["exangle"], rect["exangle"] - angle) > math.pi / 2:
                    rect["stape"] += 1
                    if rect["stape"] > rect["move"]:
                        rect["stape"] = 0
                    rect["cible"] = rect["point"][rect["stape"]]
                    y = rect["cible"][1] - rect["pos"][1]
                    x = rect["cible"][0] - rect["pos"][0]
                    angle = math.atan2(y, x)
                rect["exangle"] = angle
                mx = math.cos(angle) * rect["speed"]
                my = math.sin(angle) * rect["speed"]
                if rect["pos"][0] < joueur[0][0] < rect["pos"][2]:
                    if rect["pos"][1] - joueur[1] - 2 < joueur[0][1] < rect["pos"][1]:
                        joueur[0][0] += mx
                        joueur[0][1] += my
                rect["pos"][0] += mx
                rect["pos"][2] += mx
                rect["pos"][1] += my
                rect["pos"][3] += my
                rect["visuel"][0] += mx
                rect["visuel"][1] += my

    pygame.draw.circle(screen, colors[color_select], joueur[0], joueur[1])


# permet de connaitre une position pendant une transition
def transition(nb1, nb2, prop):
    return nb1 * prop + nb2 * (-prop + 1)


# regarde chaque input
def save_setting():
    for category in parametre:
        parametre_no_save[category] = parametre[category]


def bouton_action(select):
    global menu, lvl_select, binding, name_bind, color_select
    if menu == "main":
        if select == 1:
            menu = "level selector"
            menu_select()
        elif select == 2:
            menu = "settings"
            menu_select()
        elif select == 3:
            quite()
    elif menu == "level selector":
        if select == nb_level + 1:
            menu = "main"
            menu_select()
        else:
            menu = "level"
            menu_select()
            lvl_select = select - 1
            color_select = 0
    elif menu == "level":
        menu = "main"
        menu_select()
    elif menu == "pause":
        if select == 0:
            menu = "level"
            menu_select()
        elif select == 1:
            menu = "main"
            menu_select()
        elif select == 2:
            quite()
        elif select == 3:
            menu = "settings pause"
            menu_select()
        elif select == 4:
            menu = "level selector"
            menu_select()
    elif menu == "settings pause":
        if select == 0 or select == 1:
            menu = "pause"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybindl"
            menu_select()
    elif menu == "settings":
        if select == 0 or select == 1:
            menu = "main"
            menu_select()
            if select == 1:
                save_setting()
        elif select == 2:
            menu = "keybind"
            menu_select()
    elif menu == "keybind":
        if select == 0:
            menu = "settings"
            menu_select()
        else:
            binding = True
            i = 1
            for action in parametre["touches"]:
                if i == select:
                    name_bind = action
                i += 1
    elif menu == "keybindl":
        if select == 0:
            menu = "settings pause"
            menu_select()


def inpute():
    global mouse_pos, deltatime, menu, binding, color_select, joueur
    mouse_pos = pygame.mouse.get_pos()

    select = -1
    for bouton in boutons:
        if not bouton.only_draw:
            selectint = bouton.is_trigger(mouse_pos)
            if selectint is not None:
                select = selectint
            bouton.stape(deltatime)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            quite()
        elif event.type == pygame.KEYDOWN:
            if binding:
                parametre_no_save["touches"][name_bind] = event.key
                menu_select()
                binding = False
            elif menu == "level":
                if event.key == parametre["touches"]["PAUSE"]:
                    menu = "pause"
                    menu_select()
                elif event.key == parametre["touches"]["AVANCER DANS LES COULEURS"]:
                    color_select += 1
                    if color_select >= 6:
                        color_select -= 6
                    if color_select > lvl_select:
                        color_select -= (lvl_select + 1)
                elif event.key == parametre["touches"]["RECULER DANS LES COULEURS"]:
                    color_select -= 1
                    if color_select < 0:
                        color_select += min((lvl_select + 1), 6)
                elif event.key == parametre["touches"]["SAUTER"]:
                    if joueur[5]:
                        if graviter_variateur < 0:
                            joueur[2] += 400
                        else:
                            joueur[2] -= 400
                elif event.key == pygame.K_t:
                    joueur[0] = [mouse_pos[0], mouse_pos[1]]
                if event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = True
                if event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = True
        elif event.type == pygame.KEYUP:
            if menu == "level":
                if event.key == parametre["touches"]["GAUCHE"]:
                    joueur[7] = False
                if event.key == parametre["touches"]["DROITE"]:
                    joueur[6] = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and select != -1 and select is not None:
                bouton_action(select)


# tout est dans le nom
def quite():
    pygame.quit()
    quit()


def dist(p1, p2):
    x = p1[0] - p2[0]
    y = p1[1] - p2[1]
    return x * x + y * y


def collision(rect, pos, r):
    global graviter_variateur, joueur
    recte = rect['pos']
    if rect["trigger"]:
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1]:
                return [pos[0], pos[1] - (recte[1] - pos[1] - r) * -1]
            elif recte[3] < pos[1] < recte[3] + r:
                return [pos[0], pos[1] + (pos[1] - recte[3] - r) * -1]
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0]:
                return [pos[0] - (recte[0] - pos[0] - r) * -1, pos[1]]
            elif recte[2] < pos[0] < recte[2] + r:
                return [pos[0] + (pos[0] - recte[2] - r) * -1, pos[1]]
    elif rect["spe"]:
        if recte[0] < pos[0] < recte[2]:
            if recte[1] - r < pos[1] < recte[1] or recte[3] < pos[1] < recte[3] + r:
                graviter_variateur = rect["graviter"]
                if not rect["tp"] == [0, 0]:
                    return [rect["tp"][0] + screen_size[0], rect["tp"][1] + screen_size[1]]
                if graviter_variateur < 0:
                    joueur[2] += rect["bump"]
                else:
                    joueur[2] -= rect["bump"]
                if rect["trigger"]:
                    if recte[1] - r < pos[1] < recte[1]:
                        return [pos[0], pos[1] - (recte[1] - pos[1] - r) * -1]
                    else:
                        return [pos[0], pos[1] + (pos[1] - recte[3] - r) * -1]
        if recte[1] < pos[1] < recte[3]:
            if recte[0] - r < pos[0] < recte[0] or recte[2] < pos[0] < recte[2] + r:
                graviter_variateur = rect["graviter"]
                if not rect["tp"] == [0, 0]:
                    return [rect["tp"][0] * screen_size[0], rect["tp"][1] * screen_size[1]]
                if graviter_variateur < 0:
                    joueur[2] += rect["bump"]
                else:
                    joueur[2] -= rect["bump"]
                if rect["trigger"]:
                    if recte[0] - r < pos[0] < recte[0]:
                        return [pos[0] - (recte[0] - pos[0] - r) * -1, pos[1]]
                    else:
                        return [pos[0] + (pos[0] - recte[2] - r) * -1, pos[1]]

    return pos


def frame_stape(deltatime):
    global joueur
    expos = joueur[0][1]
    joueur[0][1] += joueur[2] * deltatime + 9.81 * deltatime * deltatime * joueur[4] * graviter_variateur
    d = joueur[0][1] - expos
    expos = joueur[0][1]
    if joueur[6]:
        joueur[0][0] += joueur[3] * deltatime
    if joueur[7]:
        joueur[0][0] -= joueur[3] * deltatime
    joueur[2] = d / deltatime
    for index in all_terrain["all"][str(color_select)]:
        joueur[0] = collision(all_terrain["all"][str(color_select)][index], joueur[0], joueur[1])
    for index in all_terrain[str(lvl_select)][str(color_select)]:
        joueur[0] = collision(all_terrain[str(lvl_select)][str(color_select)][index], joueur[0], joueur[1])
    if not expos == joueur[0][1]:
        joueur[2] = 0


menu_select()
while True:
    deltatime = clock.tick() / 1000

    affichage()
    if menu == "level":
        frame_stape(deltatime)
    inpute()
